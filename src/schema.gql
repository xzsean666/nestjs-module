# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type UserMeta {
  current_vocabulary: WordFlowVocabularyType
  target_timestamp: String
  study_phase: WordFlowPhaseType
  interest_tag: [WordFlowInterestTagType!]
  registration_id: String
}

enum WordFlowVocabularyType {
  CET4
  CET6
  GRADUATEEXAM
  TOEFL
  IELTS
  SAT
  GREHIGHFREQUENCY
  TEST
}

enum WordFlowPhaseType {
  BRUSH_WORDS
  CONSOLIDATE
  MEMORIZE_PRECISELY
}

enum WordFlowInterestTagType {
  WESTERNMUSIC
  JPOPKPOP
  MOVIES
  PSYCHOLOGY
  BUSINESSTECHNOLOGY
  GLOBALCUISINE
  WORLDTRAVEL
  HISTORY
  PHILOSOPHY
}

type MonthlyCheckin {
  yearMonth: String!
  checkedInDays: [Int!]!

  """JSON of checkin details"""
  details: JSON!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type CheckinStats {
  totalCheckins: Int!
  lastCheckin: String
  streak: Int!

  """JSON of monthly stats"""
  monthlyStats: JSON!
}

type WeeklyCheckin {
  startDate: String!
  endDate: String!
  checkedInDays: [Int!]!

  """JSON of checkin details"""
  details: JSON!
}

type SystemMessageDto {
  id: ID!
  userId: String
  category: MessageCategory!
  title: String!
  content: String!
  isRead: Boolean!
  createdAt: Float!
  expiresAt: Float
  type: MessageType!
}

"""Available message categories"""
enum MessageCategory {
  AD
  NOTIFICATION
  SUBSCRIPTION
  SYSTEM
}

"""Message type: personal or global"""
enum MessageType {
  PERSONAL
  GLOBAL
}

type BaseWordDto {
  word: String!
  updated_at: Float
}

type CardTypeCountDto {
  MIXED_CHINESE: Float!
  ENGLISH_ONLY: Float!
  FILL_IN_BLANKS: Float!
}

type StudyPlanDto {
  days_remaining: Float!
  total_unknowns: CardTypeCountDto!
  daily_goals: CardTypeCountDto!
  total_words: Float!
  generated_at: Float
  plan_date: String
  completed_at: Float
  progress_date: String
  initial_unknown_counts: CardTypeCountDto
  final_unknown_counts: CardTypeCountDto
  words_learned_count: Float
  study_completion_rate: Float
}

type DailyStatDto {
  date: String!
  words_learned: Float!
  completion_rate: Float!
  total_unknown: Float!
}

type MarkedWordDto {
  word: String!
  updated_at: Float
  tag: WordFlowMarkedWordTag
}

enum WordFlowMarkedWordTag {
  VIP
  ERROR
  FORGET
  KNOWN
  UNKNOWN
  NEW_WORD
}

type TagWordEntry {
  word: String!
  updated_at: Float
  tag: WordFlowMarkedWordTag
  explanation: JSON
}

type TagWordsResult {
  total: Int!
  words: [TagWordEntry!]!
}

type UserSubscriptionDto {
  id: String!
  user_id: String!
  plan: SubscriptionPlan!
  status: SubscriptionStatus!
  start_date: DateTime!
  end_date: DateTime!
  months_count: Float!
  price_per_month: Float!
  total_price: Float!
  payment_id: String
  promote_code: String
  promote_discount: Float
  free_months: Float
  original_price: Float
  created_at: DateTime!
  updated_at: DateTime!
}

enum SubscriptionPlan {
  MONTHLY
  QUARTERLY
  YEARLY
  CUSTOM
}

enum SubscriptionStatus {
  ACTIVE
  EXPIRED
  CANCELLED
  PENDING
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type SubscriptionPricingDto {
  monthly_price: Float!
  quarterly_discount: Float!
  yearly_discount: Float!
}

type SubscriptionPriceCalculationDto {
  totalPrice: Float!
  pricePerMonth: Float!
  discount: Float!
}

type RefundResponseDto {
  success: Boolean!
  message: String!
}

type PaymentMethodDto {
  provider: String!
  methods: [String!]!
}

type BatchReminderResultDto {
  sent: Float!
  failed: Float!
  upcomingExpiry: [UserSubscriptionDto!]!
  errors: [String!]!
}

type ExpiredSubscriptionResultDto {
  expired: Float!
  notified: Float!
  errors: [String!]!
}

type SubscriptionRevenueDto {
  total: Float!
  thisMonth: Float!
  lastMonth: Float!
}

type SubscriptionStatsDto {
  total: Float!
  active: Float!
  pending: Float!
  expired: Float!
  cancelled: Float!
  upcomingExpiry: Float!
  revenue: SubscriptionRevenueDto!
}

type EmergencyReminderResultDto {
  sent: Float!
  failed: Float!
  errors: [String!]!
}

type SubscriptionHealthCheckStatsDto {
  totalSubscriptions: Float!
  activeRate: Float!
  upcomingExpiryRate: Float!
  revenue: SubscriptionRevenueDto!
}

type SubscriptionHealthCheckDto {
  status: String!
  message: String!
  stats: SubscriptionHealthCheckStatsDto
}

type PaymentResponseDto {
  success: Boolean!
  paymentId: String!
  orderId: String!
  amount: Float!
  currency: String!
  provider: PaymentProvider!
  method: PaymentMethod!
  status: PaymentStatus!
  payData: String
  message: String
  thirdPartyOrderId: String
  createdAt: DateTime!
  expireTime: DateTime
}

enum PaymentProvider {
  WECHAT
  ALIPAY
  STRIPE
  PAYPAL
  MOCK
}

enum PaymentMethod {
  WECHAT_JSAPI
  WECHAT_NATIVE
  WECHAT_APP
  WECHAT_H5
  ALIPAY_WEB
  ALIPAY_WAP
  ALIPAY_APP
  ALIPAY_QR
  MOCK_QR
  MOCK_WEB
  MOCK_H5
  CREDIT_CARD
  BANK_TRANSFER
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
  CANCELLED
  REFUNDED
  PARTIAL_REFUNDED
}

type PromoteCodeDto {
  code: String!
  type: PromoteCodeType!
  value: Float!
  description: String!
  isActive: Boolean!
  usageLimit: Float
  usedCount: Float!
  expiryDate: DateTime
  minPurchaseAmount: Float
  applicablePlans: [String!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum PromoteCodeType {
  PERCENTAGE
  FIXED_AMOUNT
  FREE_MONTHS
}

type PromoteCodeApplicationDto {
  originalPrice: Float!
  discountAmount: Float!
  finalPrice: Float!
  freeMonths: Float
}

type PromoteCodeValidationDto {
  isValid: Boolean!
  message: String!
  application: PromoteCodeApplicationDto
  promoteCode: PromoteCodeDto
}

type SubscriptionPriceWithPromoteCodeDto {
  totalPrice: Float!
  pricePerMonth: Float!
  discount: Float!
  promoteCodeDiscount: Float
  freeMonths: Float
  finalPrice: Float!
}

type PushResponse {
  sendno: String!
  msgId: String!
  success: Boolean!
  message: String
}

type BatchPushResponse {
  results: [PushResponse!]!
  totalBatches: Float!
  totalUsers: Float!
  success: Boolean!
  message: String
}

type PushStatistics {
  msgId: String!
  data: String!
}

type PushMessageStatus {
  msgId: String!
  status: String!
}

type ConfigValidationResult {
  isValid: Boolean!
  message: String
}

input UserMetaInput {
  current_vocabulary: WordFlowVocabularyType
  target_timestamp: String
  study_phase: WordFlowPhaseType
  interest_tag: [WordFlowInterestTagType!]
  registration_id: String
}

type Query {
  test: String!
  testadmin: String!
  validatePushConfig: ConfigValidationResult!
  getPushStatistics(msgIds: [String!]!): PushStatistics!
  getPushMessageStatus(msgId: String!, registrationIds: [String!]): PushMessageStatus!
  wechatLogin(code: String!): JSON!
  mockLogin(user_id: String): JSON!
  getUserMeta: UserMeta!
  CheckinStats: CheckinStats!
  CurrentMonthCheckin: MonthlyCheckin!
  CurrentWeekCheckin: WeeklyCheckin!
  CheckinHistory(year: Int!, month: Int!): MonthlyCheckin!
  getMessages(filter: String = "all", category: MessageCategory, type: MessageType): [SystemMessageDto!]!
  getUnreadCount: Int!
  getUserKnowns: [BaseWordDto!]!
  getUserVocabulary: [String!]!
  getUserUnknowns: [String!]!
  getVocabularyExplains(word: String!): JSON
  getVocabularyExplainsBulk(words: [String!]!): JSON!
  getStudyCards(limit: Float! = 1): JSON!
  getStudyCardsFavorites(limit: Float! = 10, offset: Float! = 0, search: String): JSON!
  getStudyCardsHistory(limit: Float! = 10, offset: Float! = 0, search: String): JSON!
  getStudyPlans: StudyPlanDto!
  getStudyPlansHistory(days: Float! = 7): JSON!
  getStudyProgressSummary: JSON
  getUserVocabularyStatus: JSON!
  getUserMarkedWords(tag: WordFlowMarkedWordTag): [MarkedWordDto!]!
  getUserTagWords(tag: WordFlowMarkedWordTag!, options: GetWordsOptionsInput): TagWordsResult!
  getDailyStudyRecord(date: String!): JSON
  getStudyStatsSummary(days: Float! = 7): JSON!
  getAvailablePaymentMethods: [PaymentMethodDto!]!
  getUserActiveSubscription(userId: String!): UserSubscriptionDto
  getActiveSubscription: UserSubscriptionDto
  getUserSubscriptionHistory(userId: String!): [UserSubscriptionDto!]!
  isUserSubscribed(userId: String!): Boolean!
  getSubscriptionPricing: SubscriptionPricingDto!
  calculateSubscriptionPrice(monthsCount: Float!): SubscriptionPriceCalculationDto!
  getUpcomingExpiryUsers(daysBefore: Float = 7): [UserSubscriptionDto!]!
  getExpiredUsers: [UserSubscriptionDto!]!
  getSubscriptionStats: SubscriptionStatsDto!
  getSubscriptionHealthCheck: SubscriptionHealthCheckDto!
  validatePromoteCode(promoteCode: String!, monthsCount: Float!): PromoteCodeValidationDto!
  calculateSubscriptionPriceWithPromoteCode(monthsCount: Float!, promoteCode: String): SubscriptionPriceWithPromoteCodeDto!
  getActivePromoteCodes: [PromoteCodeDto!]!
}

input GetWordsOptionsInput {
  sortBy: WordFlowSortBy
  sortOrder: WordFlowSortOrder
  offset: Int! = 0
  limit: Int! = 10
  search: String
}

enum WordFlowSortBy {
  UPDATED_AT
  WORD
}

enum WordFlowSortOrder {
  ASC
  DESC
}

type Mutation {
  pushToAll(input: PushToAllInput!): PushResponse!
  pushToAlias(input: PushToAliasInput!): PushResponse!
  pushToTags(input: PushToTagsInput!): PushResponse!
  pushCustomMessage(input: PushCustomMessageInput!): PushResponse!
  pushRichNotificationAndroid(input: PushRichNotificationAndroidInput!): PushResponse!
  pushNotificationIOS(input: PushNotificationIOSInput!): PushResponse!
  batchPush(input: BatchPushInput!): BatchPushResponse!
  updateUserMeta(value: UserMetaInput!): Boolean!
  deleteUserMeta: Boolean!
  userCheckin: JSON!
  createMessage(title: String!, content: String!, category: MessageCategory!, type: MessageType! = PERSONAL, recipients: [String!], expiresAt: Float): SystemMessageDto!
  markAsRead(messageId: String, all: Boolean! = false, type: MessageType): Boolean!
  deleteMessage(messageId: String!): Boolean!
  cleanupExpiredMessages(type: MessageType): Float!
  updateWordStatus(input: UpdateWordStatusInput!): Boolean!
  markWordAsKnown(word: String!): Boolean!
  generateStudyCards: Boolean!
  updateCurrentStudyPlan: Boolean!
  updateWordsStatusBulk(input: UpdateWordsStatusBulkInput!): Boolean!
  markStudyCardsAsFavorites(cards: [String!]!): Boolean!
  removeStudyCardsFromFavorites(cards: [String!]!): Boolean!
  markWord(input: WordTagInput!): Boolean!
  unmarkWord(input: WordTagInput!): Boolean!
  createSubscriptionWithPayment(input: CreateSubscriptionWithPaymentDto!): PaymentResponseDto!
  createSubscription(input: CreateSubscriptionDto!): UserSubscriptionDto!
  createSubscriptionPayment(input: CreateSubscriptionPaymentDto!): PaymentResponseDto!
  handlePaymentSuccess(paymentId: String!): Boolean!
  refundSubscription(subscriptionId: String!, reason: String): RefundResponseDto!
  activateSubscription(subscriptionId: String!, paymentId: String): UserSubscriptionDto!
  cancelSubscription(subscriptionId: String!): UserSubscriptionDto!
  renewSubscription(userId: String!, monthsCount: Float!): UserSubscriptionDto!
  sendSubscriptionReminder(userId: String!, daysBefore: Float): Boolean!
  sendBatchSubscriptionReminders(daysBefore: Float = 7): BatchReminderResultDto!
  processExpiredSubscriptions: ExpiredSubscriptionResultDto!
  runDailySubscriptionCheck: Boolean!
  runEmergencyExpiryReminder: EmergencyReminderResultDto!
}

input PushToAllInput {
  alert: String!
  platform: String! = "all"
  extras: String
}

input PushToAliasInput {
  aliases: [String!]!
  alert: String!
  platform: String! = "all"
  extras: String
}

input PushToTagsInput {
  tags: [String!]!
  alert: String!
  platform: String! = "all"
  extras: String
}

input PushCustomMessageInput {
  aliases: [String!]!
  msgContent: String!
  title: String
  platform: String! = "all"
  extras: String
}

input PushRichNotificationAndroidInput {
  aliases: [String!]!
  alert: String!
  title: String!
  bigText: String
  bigPicPath: String
  extras: String
}

input PushNotificationIOSInput {
  aliases: [String!]!
  alert: String!
  badge: Float
  sound: String
  extras: String
}

input BatchPushInput {
  aliases: [String!]!
  alert: String!
  platform: String! = "all"
  batchSize: Float! = 1000
  extras: String
}

input UpdateWordStatusInput {
  word: String!
  card_type: WordFlowCardType!
}

enum WordFlowCardType {
  MIXED_CHINESE
  ENGLISH_ONLY
  FILL_IN_BLANKS
}

input UpdateWordsStatusBulkInput {
  words: [String!]!
  card_type: WordFlowCardType!
}

input WordTagInput {
  word: String!
  tag: WordFlowMarkedWordTag!
}

input CreateSubscriptionWithPaymentDto {
  monthsCount: Float!
  paymentProvider: PaymentProvider!
  paymentMethod: PaymentMethod!
  promoteCode: String
}

input CreateSubscriptionDto {
  monthsCount: Float!
  promoteCode: String
}

input CreateSubscriptionPaymentDto {
  subscriptionId: String!
  paymentProvider: PaymentProvider!
  paymentMethod: PaymentMethod!
}